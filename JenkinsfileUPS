final FAILURE = '#FF0000'

def keepgoing = true
def buildTest = JOB_NAME.contains("BuildTest")


def getPreviousStatus(build) {
    if (build == null) {
        return 'ABORTED'
    }
    if (build.result != null && build.result != 'ABORTED') {
        return build.result
    }
    return getPreviousStatus(build.getPreviousBuild())
}

def notifyStatusChange(buildStatus) {
    final UNKNOWN  = '#0000FF'
    final SUCCESS  = '#00FF00'
    final UNSTABLE = '#FFFF00'

    def color = UNKNOWN

    switch (buildStatus) {
        case 'SUCCESS':
            color = SUCCESS
            break

        case 'UNSTABLE':
            color = UNSTABLE
            break
    }

    // Notification already happened if 'FAILURE'. We don't care about canceled builds
    def prevStatus = getPreviousStatus(currentBuild.getPreviousBuild())
    if (buildStatus != prevStatus && buildStatus != 'FAILURE' && buildStatus != 'ABORTED' && prevStatus != 'ABORTED') {
        echo "Status notifcation (previous, current): ${prevStatus}, ${buildStatus}"
        sendNotification(color, buildStatus)
    }
}

def sendNotification(color, buildStatus) {
    slackSend(color: color, message: buildStatus + ": ${env.JOB_NAME} [${env.BUILD_NUMBER}] (<${env.BUILD_URL}|open>)")
}

def definePackageName() {
    if (params.PRODUCTION) {
    	return "${env.BRANCH_NAME}-${env.BUILD_NUMBER}"
    }
    return "${env.BRANCH_NAME}-dev-${env.BUILD_NUMBER}"
}


pipeline {
    agent { label "UPSTREAM" }

    options {
        buildDiscarder(logRotator(daysToKeepStr: '30', artifactNumToKeepStr: '2'))
        disableConcurrentBuilds()
    }

    parameters {
        string(defaultValue: '/scratch/packages/ceph-ansible', description: 'Path to package archive, branch added ' +
                'automatically', name: 'ARCHIVE_ROOT')
        string(defaultValue: '/scratch/www/local/ceph-ansible', description: 'Path to package repo server ' +
                '(production only), branch added automatically', name: 'WWW_ROOT')
        booleanParam(defaultValue: false, description: 'Create a production build.', name: 'PRODUCTION')
    }

    environment {
	// This is phony build; all we want to do is
	// tar up our ceph-ansible branch so that it untars
	// under a directory named ${BASE_NAME}. To do this
	// a symlik is created in ${WORK_DIR} that points
	// back to ${WORKSPACE} and then we tar with --dereference
        //	
	BASE_NAME = definePackageName()
	TAR_NAME = "ceph-ansible-${env.BASE_NAME}.tgz"
	WORK_DIR = "/tmp/ceph-ansible_work/${env.BRANCH_NAME}"

	ARCHIVE_DST_DIR = "${params.ARCHIVE_ROOT}/${env.BRANCH_NAME}"
	ARCHIVE_TAR = "${env.ARCHIVE_DST_DIR}/${env.TAR_NAME}"
	ARCHIVE_NON_PRODUCTION_TOKEEP = "5"

	WWW_DST_DIR = "${params.WWW_ROOT}/${env.BRANCH_NAME}"
    }
    stages {
        stage('CheckCause') {
            when {
                expression {
                    buildTest &&
                    "${currentBuild.getBuildCauses('jenkins.branch.BranchEventCause').size()}" != "0"
                }
            }
            steps {
                script {
                    currentBuild.result = 'ABORTED'
                    keepgoing = false
                    echo "Skipping build caused by: ${currentBuild.getBuildCauses()[0].shortDescription}"
                }
            }
        }

        stage('Clean') {
            when { expression { keepgoing } }
            steps {
                sh "sudo rm -fr ${env.WORK_DIR}"
		sh "sudo git clean -xdf"
                sh "sudo mkdir -p ${env.WORK_DIR}"
                sh "sudo chmod -R 777 ${env.WORK_DIR}"
            }
        }
	
        stage('SymLinkCephAnsible') {
            when { expression { keepgoing } }
            steps {
                   sh "cd ${env.WORK_DIR} && ln -s ${WORKSPACE} ${env.BASE_NAME}"
            }
        }

        stage('Archive') {
            when { expression { keepgoing && !buildTest } }
            steps {
                sh "sudo mkdir -pm 777 ${env.ARCHIVE_DST_DIR}/ || true"
                sh "sudo tar -czvf ${env.ARCHIVE_TAR} -C ${env.WORK_DIR} --exclude-vcs --dereference ${env.BASE_NAME}"
                sh "sudo chmod 664 ${env.ARCHIVE_TAR}"
            }
        }

        stage('WWWput') {
            when { expression { keepgoing && params.PRODUCTION && !buildTest } }
            steps {
                sh "sudo mkdir -pm 777 ${env.WWW_DST_DIR}/ || true"
                sh "cp -av ${env.ARCHIVE_TAR} ${env.WWW_DST_DIR}/${env.TAR_NAME}"
                sh "sudo chmod 664 ${env.WWW_DST_DIR}/${env.TAR_NAME}"

                dir("${WWW_DST_DIR}") {
                    sh "ln -sf ${env.TAR_NAME} latest"
                    sh "echo ${env.TAR_NAME} > latest.txt"
                    sh "sudo chmod 666 latest.txt"
                }
		sh "sudo rm -fr ${env.WWW_DST_DIR}@tmp"
            }
        }


        stage('PostClean') {
            when { expression { keepgoing } }
            steps {
                sh "sudo rm -fr ${env.WORK_DIR}"
            }
        }

        stage('ArtifactClean') {
            when { expression { keepgoing && !params.PRODUCTION && !buildTest } }
            steps {
                sh "sudo ls -1t ${env.ARCHIVE_DST_DIR}/*-dev-*.tgz| tail -n +${env.ARCHIVE_NON_PRODUCTION_TOKEEP} | xargs rm -f"
            }
        }
    }

    post {
        success {
            notifyStatusChange(currentBuild.currentResult)
        }
        failure {
            sendNotification(FAILURE, currentBuild.currentResult)
        }
    }
}
